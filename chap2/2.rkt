#lang racket

(define (map proc items)
    (if (null? items)
        '()
        (cons (proc (car items)) (map proc (cdr items)) )
    )
)
; (maps (lambda (x) (* x x)) (list 3 4 1 2))
; (define x (cons (list 1 2) (list 3 4)))
; (length x)
; (list x x)
; (length (list x x))
; (cdr (list x x))
; (length (cdr (list x x)))
(define (scare-tree tree factor)
    (map (lambda (sub-tree)
            (if (pair? sub-tree)
                 (scare-tree sub-tree factor)
                (* factor sub-tree)
            )
        )
        tree   
    )
)
; (scare-tree (list 1 (list 2(list 3 4)) (list 6 7)) 10)
(define (filter predicate sequence)
    (cond ((null? sequence) null) 
        ((predicate (car sequence))
            (cons (car sequence) (filter predicate (cdr sequence))))
        (else (filter predicate (cdr sequence)))
    )
)
; (filter odd? '(1 2 3 4 5))

(define (accumulate op initial sequence)
    (if (null? sequence) initial
        (op (car sequence) (accumulate op initial (cdr sequence)))
        )
)
; (accumulate + 0 '(1 2 3 4))

(define (range low high)
    (if (> low  high)
        null
        (cons low (range (+ low 1) high))
    )
)
; (range 1 10)
(define (fib n)
    (cond ((= n 1) 1)
        ((= n 2) 1)
        ((> n 2) (+ (fib (- n 1)) (fib (- n 2))) )
    )
)
; (define (even-fibs n)
;     (filter even? 
;         (map fib (range 1 n)))
; )
(define (even-fibs n)
(accumulate cons null
    (filter even? 
        (map fib (range 1 n))))
)
; (even-fibs 10)
; (append (list 1 2 3) (list 3 4 5))
; (cons (list 1 2 3) (cons (list 3 4 5) null))

(define (flatmap proc sequence)
    (accumulate append null
        (map proc sequence) )
)
; (flatmap (lambda(x) (list (add1 x))) (range 1 10))
(define (remove x s)
    (filter (lambda (y) (not (= x y))) s
    )
)
(define (permutations s)
    (if (null? s)
        (list null)
        (flatmap (lambda (x) 
                    (map (lambda (y) (cons x y))
                    (permutations (remove x s))
                )) 
        s)
    )
)
; (permutations (range 1 1))